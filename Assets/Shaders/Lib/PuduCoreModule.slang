module PuduCore;

static const float PI = 3.14159265358979f;


public float LinearizeDepth(float d,float zNear,float zFar)
{
    return zNear * zFar / (zFar + d * (zNear - zFar));
}

public float3 DecodeNormal(float2 n)
{
    float2 m = n*2. - 1.;
    var z = sqrt(1. - m.x*m.x - m.y*m.y);

    return normalize(float3(m,z));
}

public float3 TangentToWorld(float3 v, float3 t, float3 bt, float3 n)
{
    return normalize( v.x*t + v.y*bt + v.z*n);
}

public float3 WorldToTangent(float3 v, float3 t, float3 bt, float3 n)
{
    return mul(float3x3(
        t,
        bt,
        n
    ), v);
}

public float2 ParallaxUV(float h, float2 uv, float3 viewDir, float scale, float3 t, float3 bt,float3 n)
{
    float3 tangentView = normalize(WorldToTangent(viewDir,t,bt, n));

    return uv + h*scale*tangentView.xy;
}

//Returns line intersection, it assume that lines intersect
public float3 Line3D_Intersect(float3 pA0, float3 pA1, float3 pB0, float3 pB1)
{
    //Parametrization of linear equations system generated by making line A equal to line B
    float3 A = pA0 - pB0;
    float3 u = pA1 - pA0;
    float3 v = pB1 - pB0;

    float t = ((v.x * A.y) - (v.y * A.x))/((v.y * u.x) - (v.x * u.y));

    return pA0 + (pA1 - pA0) * t;
}

public float2 ParallaxOcclusionMapping(Sampler2D heightMap, float2 uv, float3 viewDirTS, float scale) {
    const float minLayers = 16;
    const float maxLayers = 32;
    float numLayers = lerp(maxLayers, minLayers, abs(dot(float3(0.0, 0.0, 1.0), viewDirTS)));
    
    // calculate the size of each layer
    float layerDepth = 1.0 / numLayers;
    // depth of current layer
    float currentLayerDepth = 0.0;
    // the amount to shift the texture coordinates per layer (from vector P)
    float2 P = viewDirTS.xy / viewDirTS.z * scale;
    float2 deltaTexCoords = P / numLayers;

    // get initial values
    float2 currentUv = uv;
    float currentDepthMapValue = 1.0 - heightMap.Sample(currentUv).r;

    while (currentLayerDepth < currentDepthMapValue) {
        // shift texture coordinates along direction of P
        currentUv -= deltaTexCoords;
        // get depth of current layer
        currentDepthMapValue = 1.0 - heightMap.Sample(currentUv).r;
        // get depth of next layer
        currentLayerDepth += layerDepth;
    }

    return currentUv;
}

public struct POMS_OUT
{
    public float2 uv;
    public bool hit;
    }
public POMS_OUT ParallaxOcclusionMapping_Shadow(Sampler2D heightMap, float2 uv, float3 viewDirTS,float3 lightDirTS, float scale) {
    const float minLayers = 128;
    const float maxLayers = 512;
    float numLayers = lerp(maxLayers, minLayers, abs(dot(float3(0.0, 0.0, 1.0), viewDirTS)));

    // calculate the size of each layer
    float layerDepth = 1.0 / numLayers;
    // depth of current layer
    float currentLayerDepth = 1.0;
    // the amount to shift the texture coordinates per layer (from vector P)
    float2 P = viewDirTS.xy / viewDirTS.z * scale;
    float2 deltaTexCoords = -P / numLayers;

    // get initial values
    float2 currentUv = uv;
    float currentDepthMapValue = heightMap.Sample(currentUv).r;

    float3 previousPos;
    float previousDepth;

    while (currentLayerDepth > currentDepthMapValue) {
        previousPos = float3(currentUv, currentLayerDepth);
        previousDepth = currentDepthMapValue;

        currentUv += deltaTexCoords;
        currentDepthMapValue = heightMap.Sample(currentUv).x;
        currentLayerDepth -= layerDepth;
    }

    float3 currentPos = float3(currentUv,currentLayerDepth);

    float3 pA0 = previousPos;
    float3 pA1 = currentPos;

    float3 pB0 = float3(previousPos.xy,previousDepth);
    float3 pB1 = float3(currentPos.xy,currentDepthMapValue);

    float3 intersectionPoint = Line3D_Intersect(pA0,pA1,pB0,pB1);

    currentUv = intersectionPoint.xy;

    //UV Found. Look for shadow
    numLayers = lerp(maxLayers,minLayers,abs(dot(float3(0,0,1),lightDirTS)));
    P = lightDirTS.xy/lightDirTS.z * scale;
    layerDepth = 1./numLayers;
    deltaTexCoords = P/numLayers;

    currentLayerDepth = currentDepthMapValue;
    float2 shadowUv = currentUv;
    bool shadow = false;
//     while(currentLayerDepth>0)
//     {
//         shadowUv -=deltaTexCoords;
//         currentDepthMapValue = heightMap.Sample(shadowUv).r;
//
//         currentLayerDepth+=layerDepth;
//
//         if(currentLayerDepth>currentDepthMapValue)
//             shadow = true;
//     }

    return {currentUv,shadow};
}
